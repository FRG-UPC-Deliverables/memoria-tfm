\chapter{Cross-platform development}

At the beginning of computers, each hardware manufacturer had to decide how
access to its hardware functionalities. Since there were no standards for some
cases, the first inter-compatibility problems started to appear because
programs were not able to run on different computers.

To reduce these problems drivers were created. A driver is a piece of code that 
maps logic functions (for instance, turn on a led) to hardware operations 
(short circuit some part of the electronics). Programs call this logic functions
so for them it's not important how to turn on the led, is the driver who 
specifies how to do it. Then, for software, the only important part is how these
functions are called.

Logic functions are provided to programs by the Operative Systems (OS) so the 
problem now is that not all OS use the same functions names.

\section{Technological soup}

Nowadays lots of technologies has been created with the goal of writing just
one code to run in as many platforms possible. We want to achieve this
in order to reduce the development cost, but this results in a performance
reduction.

The most intuitive solution may be to use cross-platform frameworks to perform
the functions that have problems with interoperability. These frameworks have 
conditionals that execute a logic function or another depending on which 
operative system is the one that is compiling this library.

But the common way to achieve this goal is with scripting programming
languages. These are human readable text and are interpreted by a program
called interpreter during the execution time. One step further is to compile
them into pseudo-machine code that is easy to understand for the interpreter.
This second group of is known as virtual machine programming languages. This
have the advantage that programs are faster, but developers lose some time
compiling the code each time they want to test something. Both technologies can
run over all the platforms that its interpreter is supported.

Another kind of solutions are transcompilers or source-to-source compilers. They
translate from one programming language to many others. This translation could
be done in a scripting language (there interoperability is provided) or can make
a specific translation to a compiled language depending on the OS.

\subsection{Java}

This well-known programming language is one of the most used to build
cross-platform applications due to its maturity. Java is a general-purpose,
concurrent, classbased, object-oriented language and it's designed to be easy
to learn in order to let many programmers to have fluency in the language
\cite{java-8-specs}.

Classic compiled languages, such as, C and C++, directly compile into machine
code, which is directly interpreted by the hardware. As opposed to C and C++,
Java can be considered a virtual machine programming language.

\begin{codefigure}{Java hello world}{F:java-hello-world}
	\javaexternal{source/HelloWorldApp.java}
\end{codefigure}

Figure \ref{F:java-hello-world} is an example of Java program that prints the
test “Hello World!” into the terminal.

\subsection{Qt}

A complete cross-platform software framework with ready-made UI elements, C++ 
libraries, and a complete integrated development environment with tools for 
everything you need to develop software for any project \cite{qt-web}.

\begin{codefigure}{Qt hello world}{F:qt-hello-world}
	\cppexternal{source/qt_hello_world.cpp}
\end{codefigure}

\subsection{Python}

This is an example of a scripting programming language. The main design rule
was to be very easy to read.

It's also a considered an object-oriented language suitable for many purposes.
It has a clear, intuitive syntax, powerful high-level data structures, and a
flexible dynamic type system \cite{An93pythonfor}.

Python is often used to create terminal programs or web services because GUI
are not supported by default but there are many frameworks that can be used,
for instance, \textbf{Kivy}.

\begin{codefigure}{Kivy hello world}{F:kivy-hello-world}
	\pythonexternal{source/kivy_hello_world.py}
\end{codefigure}

\subsection{JavaScript}

JavaScript is also a well know scripting programming language. It's used
alongside with HTML and CSS as core technologies to make any webpages. But due
to its flexibility is used on many other fields as game programming or desktop
applications.

It has many interpreters but all of them has to fulfill ECMAScript 
specification. V8 is an example of JavaScript engine used in Google Chrome and
Node.js. This latest is to build desktop applications in JavaScript.

Developing trends of last years to create cross-platform applications were to 
develop a web application because all platforms have browsers. For this reason,
web technologies grow a lot but the problem is that the user experience of a
web page will never be as good as using a desktop application.

\subsubsection{Electron}

Electron is a Node.js framework that lets you build cross-platform desktop apps
with JavaScript, HTML, and CSS \cite{electron-web}. Since web technologies, due
to web applications, has grown, now are able to race with other desktop
technologies. The idea of Electron is to take profit of the fact that Node.js
and Chrome use the same JavaScript engine to let Node instantiate browser
windows that also run Node.js.

So using Electron, developers are able to create cross-platform desktop 
applications using the same technologies that the ones used to create a web
page.

\subsubsection{NW.js}

NW.js, previously known as node-webkit, works on the contrary of Electron. It's
a Chrome web browser where you can call all the node modules \cite{nwjs-web}.
So the main difference is the entry point of the application. In Electron, the
start point of your program execution is Node.js while on NW.js the entry point
is an HTML file.

\subsection{Haxe}

Finally, Haxe is a high-level open source programming language that can be 
transcompiled many other languages. It has an ECMAScript-oriented syntax but 
with the peculiarity that can be typed \cite{what-is-haxe}. 

\begin{table}[htb]
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
{\bf Name }		& {\bf Output Type} & {\bf Main usages}  \\ \hline \hline
JavaScript		& Sourcecode		& Browser, Desktop, Mobile, Server \\ \hline
Neko			& Bytecode			& Desktop, Server   \\ \hline
PHP				& Sourcecode		& Server   \\ \hline
Python			& Sourcecode		& Desktop, Server   \\ \hline
C++				& Sourcecode		& Desktop, Mobile, Server   \\ \hline
ActionScript 3	& Sourcecode		& Browser, Desktop, Mobile   \\ \hline
Flash			& Bytecode			& Browser, Desktop, Mobile   \\ \hline
Java			& Sourcecode		& Desktop, Server   \\ \hline
C\#				& Sourcecode		& Desktop, Mobile, Server   \\ \hline
\end{tabular}
\caption{Haxe use cases \cite{what-is-haxe}}
\label{T:haxe-use-cases}
\end{center}
\end{table}

Table \ref{T:haxe-use-cases} shows up many languages in which Haxe can be
compiled. Then lets see a bit of Haxe syntax.

\begin{codefigure}{Haxe hello world}{F:haxe-hello-world}
	\haxeexternal[
		classoffset=1,
		morekeywords={Main}
	]{source/Main.hx}
\end{codefigure}

As we can see in Figure \ref{F:haxe-hello-world}, Haxe can be typed defining 
variables that way: \haxeinline{var text: String}. Then, this code can be
compiled for example to Python other languages using the terminal command:

\begin{bashcode}
	haxe -main Main.hx -python \textless\text{outfile.py}\textgreater
\end{bashcode}

\section{Electron}

The technology that fits better with the project specifications is Electron. 
There are several projects like this one that are developed using this 
framework. Even it is not as mature as other ones it had a bit impact in the
developers community.

% TODO: PUT SOME EXAMPLES?? 
% Visual Studio Code, Atom, Slack, Github Desktop

Furthermore, the development of web applications has been evolved very fast with
the objective to have complex programs with a very good scalability and without
putting so much effort.

Now lets see how it works a little more in detail. Complete code of following 
examples can be seen on Appendix BLABLA

% TODO: CREATE APPENDIX

\subsection{Main process}

Since JavaScript is single threaded, to work in parallel Electron have several
processes. The initial one is called main process. It in charge of create all
browser windows, communicate them, to build application menus and control
context events.

\begin{codefigure}{Electron app events}{F:electron-app-events}
	\jsexternal{source/electron-app.js}
\end{codefigure}

Code of Figure \ref{F:electron-app-events} is an example of the most common
handled events. The most important is the \textit{"ready"} event, which is in
charge to create the main window of the application.

\subsection{Browser window}

Once event \textit{"ready"} is called, browser windows can be created. Each
window have its own process and are called renderer processes. The way to
create windows is shown on Figure \ref{F:electron-create-window}.

\begin{codefigure}{Electron window creation}{F:electron-create-window}
	\jsexternal[
		classoffset=1,
		morekeywords={BrowserWindow},
	]{source/electron-create-window.js}
\end{codefigure}

Browser windows can be created using several parameters to define its initial
behavior, for instance: width, height, position, etc. Also, they can load files 
using several protocols. In Electron, the most common way is to use local files
to reduce the load time and let the application work without Internet 
connection. And finally applications also have events, for example: 
\textit{"closed"}, \textit{"ready-to-show"}, \textit{"move"}\dots

\subsection{Menu and context menu}

% TODO: DE MOMENTO NADA

\subsection{Interprocess communication}

Finally, to be able to communicate the main process and renderer processes, 
Electron provides an interprocess communication system (IPC). It can be both
ways, main to renderer and renderer to main.

To communicate two renderer processes, a bridge must be created inside the 
main process.

\section{Web technologies}

To improve project's scalability and maintainability several web technologies
are used.

\subsection{Typescript}

Typescript is typed superset of JavaScript that compiles to plain JavaScript
created by Microsoft \cite{typescript-web}. It has two main advantages:

\begin{description}
	\item[Typed language]
	Since Typescript is a typed language and it has a compilation process, any
	mismatch of parameters in a function call can be detected. This is useful
	to check if something is not well programmed before test the application.
	
	Also, Integrated Development Environments (IDEs) can help developers before
	type mismatches happens because now this information is provided.
	
	\item[Compiles to plain Javascript]
	There are many web browsers and not all of them are not providing the same
	JavaScript functionalities. To use TypeScript allows developer to not take
	care of it because is the compiler who chooses the proper JavaScript code.

\end{description}

Many JavaScript libraries also provide its TypeScript typings. Using this 
information, the compiler can detect if the library is properly used.

Each time TypeScript is compiled, a tool called TsLint can be used to
check if some programming style guides are followed. They help to keep the code
easy-to-read because some rules are used, for instance: the use of lower camel 
case for variables and upper camel case for classes.

\subsection{Sass}

Like Typescript is a code transcompiler, but it translates from sass to css. It
is designed to improve CSS functionalities.

\begin{codefigure}{Sass example}{F:sass-example}
	\sassexternal[
		classoffset=2,
		morekeywords={\$app_green, flex-row}
	]{source/example.scss}
\end{codefigure}

Figure \ref{F:sass-example} helps to see all the advantages that Sass provides.
The main of them are:

\begin{description}
	\item[Nesting CSS selectors]
	Improves code scalability. 
	
	\item[Variables]
	Helps to define palettes, sizes, etc.
	
	\item[Mixins]
	They are similar to functions. Is very useful to define common behaviors.
	
\end{description}

% TODO: Explicar que se ha estructurado scss por componentes visuales??

\subsection{Gulp}

Gulp is a toolkit for automating painful or time-consuming tasks in your
development workflow, so you can stop messing around and build something
\cite{gulp-web}.

This project has several routine tasks, such as launch electron, compile
Typescript and Sass each time a file change happens, etc. For this reason, 
several gulp tasks to help development.

% TODO: Poner un ejemplo de una tarea de gulp configurada??